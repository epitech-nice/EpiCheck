/**
 * File Name: office365Auth.ts
 * Author: Alexandre KÃ©vin DE FREITAS MARTINS
 * Creation Date: 29/10/2025
 * Description: This is the office365Auth.ts
 * Copyright (c) 2025 Epitech
 * Version: 1.0.0
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the 'Software'), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

import { Platform } from "react-native";
import * as WebBrowser from "expo-web-browser";
import * as AuthSession from "expo-auth-session";
import * as SecureStore from "expo-secure-store";

// Complete the authentication session properly
WebBrowser.maybeCompleteAuthSession();

// Storage wrapper that works on web and native
const storage = {
    async setItem(key: string, value: string): Promise<void> {
        if (Platform.OS === "web") {
            localStorage.setItem(key, value);
        } else {
            await SecureStore.setItemAsync(key, value);
        }
    },

    async getItem(key: string): Promise<string | null> {
        if (Platform.OS === "web") {
            return localStorage.getItem(key);
        } else {
            return await SecureStore.getItemAsync(key);
        }
    },

    async deleteItem(key: string): Promise<void> {
        if (Platform.OS === "web") {
            localStorage.removeItem(key);
        } else {
            await SecureStore.deleteItemAsync(key);
        }
    },
};

// Azure AD Configuration
// IMPORTANT: Replace these with your actual Azure AD app registration values
const AZURE_AD_CONFIG = {
    // Client ID from Azure AD App Registration
    clientId: "985e002b-598c-41a8-81a0-0c1d482f0bfb",

    // Tenant ID - Use 'organizations' for multi-tenant or specific tenant ID
    // For Epitech, this should be Epitech's tenant ID
    tenantId: "organizations", // or 'YOUR_EPITECH_TENANT_ID'

    // Scopes requested
    scopes: [
        "openid",
        "profile",
        "email",
        "User.Read",
        "offline_access", // For refresh token
    ],

    // Redirect URI (automatically generated by expo-auth-session)
    // In Azure AD, you need to add: exp://[your-ip]:19000 for development
    redirectUri: AuthSession.makeRedirectUri({
        scheme: "epiccheck",
        path: "auth",
    }),
};

// Microsoft Graph API endpoints
const GRAPH_API_BASE = "https://graph.microsoft.com/v1.0";

// Azure AD endpoints
const getAuthEndpoint = () =>
    `https://login.microsoftonline.com/${AZURE_AD_CONFIG.tenantId}/oauth2/v2.0/authorize`;
const getTokenEndpoint = () =>
    `https://login.microsoftonline.com/${AZURE_AD_CONFIG.tenantId}/oauth2/v2.0/token`;

// SecureStore keys
const KEYS = {
    ACCESS_TOKEN: "office365_access_token",
    REFRESH_TOKEN: "office365_refresh_token",
    TOKEN_EXPIRY: "office365_token_expiry",
    USER_INFO: "office365_user_info",
};

export interface Office365UserInfo {
    id: string;
    displayName: string;
    givenName: string;
    surname: string;
    userPrincipalName: string; // email
    mail: string;
    jobTitle?: string;
    officeLocation?: string;
}

export interface AuthTokens {
    accessToken: string;
    refreshToken?: string;
    expiresIn: number;
    tokenType: string;
}

class Office365AuthService {
    private discovery = {
        authorizationEndpoint: getAuthEndpoint(),
        tokenEndpoint: getTokenEndpoint(),
    };

    /**
     * Initiate Office 365 login flow
     */
    async login(): Promise<Office365UserInfo> {
        try {
            console.log("Creating auth request with config:", {
                clientId: AZURE_AD_CONFIG.clientId,
                redirectUri: AZURE_AD_CONFIG.redirectUri,
            });

            // Create authorization request
            const request = new AuthSession.AuthRequest({
                clientId: AZURE_AD_CONFIG.clientId,
                scopes: AZURE_AD_CONFIG.scopes,
                redirectUri: AZURE_AD_CONFIG.redirectUri,
                responseType: AuthSession.ResponseType.Code,
                usePKCE: true,
                extraParams: {
                    prompt: "select_account", // Always show account picker
                    domain_hint: "epitech.eu", // Suggest Epitech domain
                },
            });

            console.log("Prompting for authorization...");
            // Prompt for authorization
            const result = await request.promptAsync(this.discovery);
            console.log("Auth result type:", result.type);

            if (result.type === "success" && result.params.code) {
                console.log("Auth code received, exchanging for tokens...");
                // Exchange code for tokens
                const tokens = await this.exchangeCodeForTokens(
                    result.params.code,
                    request.codeVerifier!,
                );

                console.log("Tokens received, storing...");
                // Store tokens securely
                await this.storeTokens(tokens);

                console.log("Fetching user info...");
                // Fetch and store user info
                const userInfo = await this.getUserInfo(tokens.accessToken);
                console.log("User info received:", userInfo.displayName);

                await this.storeUserInfo(userInfo);
                console.log("Login process complete");

                return userInfo;
            } else if (result.type === "error") {
                console.error("Auth error:", result.error);
                throw new Error(
                    result.error?.message || "Authentication failed",
                );
            } else {
                console.log("Auth cancelled or dismissed");
                throw new Error("Authentication was cancelled");
            }
        } catch (error: any) {
            console.error("Office365 login error:", error);
            throw new Error(
                error.message || "Failed to authenticate with Office 365",
            );
        }
    }

    /**
     * Exchange authorization code for access/refresh tokens
     */
    private async exchangeCodeForTokens(
        code: string,
        codeVerifier: string,
    ): Promise<AuthTokens> {
        try {
            const response = await fetch(getTokenEndpoint(), {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                },
                body: new URLSearchParams({
                    client_id: AZURE_AD_CONFIG.clientId,
                    scope: AZURE_AD_CONFIG.scopes.join(" "),
                    code: code,
                    redirect_uri: AZURE_AD_CONFIG.redirectUri,
                    grant_type: "authorization_code",
                    code_verifier: codeVerifier,
                }).toString(),
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(
                    error.error_description || "Token exchange failed",
                );
            }

            const data = await response.json();

            return {
                accessToken: data.access_token,
                refreshToken: data.refresh_token,
                expiresIn: data.expires_in,
                tokenType: data.token_type,
            };
        } catch (error: any) {
            console.error("Token exchange error:", error);
            throw error;
        }
    }

    /**
     * Get user information from Microsoft Graph API
     */
    async getUserInfo(accessToken: string): Promise<Office365UserInfo> {
        try {
            const response = await fetch(`${GRAPH_API_BASE}/me`, {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            });

            if (!response.ok) {
                throw new Error("Failed to fetch user information");
            }

            const data = await response.json();
            return data;
        } catch (error: any) {
            console.error("Get user info error:", error);
            throw error;
        }
    }

    /**
     * Refresh access token using refresh token
     */
    async refreshAccessToken(): Promise<string> {
        try {
            const refreshToken = await storage.getItem(KEYS.REFRESH_TOKEN);

            if (!refreshToken) {
                throw new Error("No refresh token available");
            }

            const response = await fetch(getTokenEndpoint(), {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                },
                body: new URLSearchParams({
                    client_id: AZURE_AD_CONFIG.clientId,
                    scope: AZURE_AD_CONFIG.scopes.join(" "),
                    refresh_token: refreshToken,
                    grant_type: "refresh_token",
                }).toString(),
            });

            if (!response.ok) {
                throw new Error("Token refresh failed");
            }

            const data = await response.json();

            // Store new tokens
            await this.storeTokens({
                accessToken: data.access_token,
                refreshToken: data.refresh_token || refreshToken,
                expiresIn: data.expires_in,
                tokenType: data.token_type,
            });

            return data.access_token;
        } catch (error: any) {
            console.error("Refresh token error:", error);
            // If refresh fails, clear tokens and require re-login
            await this.logout();
            throw new Error("Session expired. Please login again.");
        }
    }

    /**
     * Store authentication tokens securely
     */
    private async storeTokens(tokens: AuthTokens): Promise<void> {
        try {
            await storage.setItem(KEYS.ACCESS_TOKEN, tokens.accessToken);

            if (tokens.refreshToken) {
                await storage.setItem(KEYS.REFRESH_TOKEN, tokens.refreshToken);
            }

            // Calculate and store expiry timestamp
            const expiryTime = Date.now() + tokens.expiresIn * 1000;
            await storage.setItem(KEYS.TOKEN_EXPIRY, expiryTime.toString());
        } catch (error) {
            console.error("Error storing tokens:", error);
        }
    }

    /**
     * Store user information
     */
    private async storeUserInfo(userInfo: Office365UserInfo): Promise<void> {
        try {
            await storage.setItem(KEYS.USER_INFO, JSON.stringify(userInfo));
        } catch (error) {
            console.error("Error storing user info:", error);
        }
    }

    /**
     * Get stored access token
     */
    async getAccessToken(): Promise<string | null> {
        try {
            const token = await storage.getItem(KEYS.ACCESS_TOKEN);
            const expiry = await storage.getItem(KEYS.TOKEN_EXPIRY);

            if (!token || !expiry) {
                return null;
            }

            // Check if token is expired (with 5 minute buffer)
            const isExpired = Date.now() + 5 * 60 * 1000 > parseInt(expiry);

            if (isExpired) {
                // Try to refresh token
                try {
                    return await this.refreshAccessToken();
                } catch {
                    return null;
                }
            }

            return token;
        } catch (error) {
            console.error("Error getting access token:", error);
            return null;
        }
    }

    /**
     * Get stored user information
     */
    async getUserInfoFromStorage(): Promise<Office365UserInfo | null> {
        try {
            const userInfoStr = await storage.getItem(KEYS.USER_INFO);
            if (!userInfoStr) return null;
            return JSON.parse(userInfoStr);
        } catch (error) {
            console.error("Error getting user info from storage:", error);
            return null;
        }
    }

    /**
     * Check if user is authenticated
     */
    async isAuthenticated(): Promise<boolean> {
        const token = await this.getAccessToken();
        return token !== null;
    }

    /**
     * Logout and clear all stored data
     */
    async logout(): Promise<void> {
        try {
            await storage.deleteItem(KEYS.ACCESS_TOKEN);
            await storage.deleteItem(KEYS.REFRESH_TOKEN);
            await storage.deleteItem(KEYS.TOKEN_EXPIRY);
            await storage.deleteItem(KEYS.USER_INFO);
        } catch (error) {
            console.error("Error during logout:", error);
        }
    }

    /**
     * Get configuration info for setup
     */
    getConfig() {
        return {
            clientId: AZURE_AD_CONFIG.clientId,
            redirectUri: AZURE_AD_CONFIG.redirectUri,
            scopes: AZURE_AD_CONFIG.scopes,
        };
    }
}

export default new Office365AuthService();
